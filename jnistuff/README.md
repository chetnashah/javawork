

A decent overview is JavaOne talk :
https://www.youtube.com/watch?v=_cFwDnKvgfw

1. It is possible to call native code from Java (Mostly used case):

On java side :
  declare the methode to be called wit modifier native.
  Use System.LoadLibrary("libXyz.so")
    How will System.loadlibrary look for my xyz.so ?
      1. default search path
      2. Environment LD_LIBRARY_PATH=`dir with xyz.so`
      3. CMD line -Djava.library.path=`dir with xyz.so`
      
  Next step is to compile your java code using javac
  javac MyApp.java
  javah -jni myApp // generates headers to be used in native proj
  
  



2. It is possible to call Java code from native (rarely used):


### What does java side look like?

```java
public class JavaToC {

    // implemented in C/C++
    public native void getHelloFromC();

    // load library
    static {
        System.loadLibrary("HelloWorld");// note no "lib" keyword needednote 
    }

    public static void main(String[] args) {
        new JavaToC().getHelloFromC();
    }
}
```
**Note** - no `lib` keyword needed,
Java will automatically search as per OS e.g.
`libHelloWorld.so` on linux/unix
and `HelloWorld.dll` on windows

### c++ side of things

`JNIEnv* env, jobject thiz` get passed into every method by default.
the real arguments follow after these two parameters.

cryptic method signatures are auto generated by `javah` and ides

#### first create class

Java side:
```java
private native String getLine(String prompt);
```

Make it into a class first
```
javac Prompt.java
```

`javah` will read `Prompt.class` and generate `Prompt.h`
```
javah -jni Prompt
```

```
//Prompt.h
JNIEXPORT jstring JNICALL
     Java_Prompt_getLine(JNIEnv *, jobject, jstring);
```

### JNI Primitive types mapping

`boolean` <-> `jboolean`
`byte` <-> `jbyte`
`char` <-> `jchar`
`int` <-> `jint`
`long` <-> `jlong`
`void` <-> `void`

### jobject


An `Object` from java is mapped as `jobject`
An `String` from java is mapped as `jstring`
An `Class<T>` from java is mapped to `jclass`

`Arrays`: `jarray` for generic array but for primitive
arrays, one would have `jintarray`, `jshortarray`, .. etc

Foor array of objects it would be `jobjectarray`.


### JNIEnv

`JNIEnv` is a god object, an interface to JVM and ticket
to working with Java objects.


### field descriptor format
`boolean` - `Z`
`byte` - `B`
`char` - `C`
`double` - `D`
`int` - `I`
`long` - `L`
`void` - `V`
`Reference` - `L<full/qualified/name>`
`Array` - `[+Signature`

### Can you have static native methods?

`Native` methods can be `static` or non-`static` just like regular java methods.

`non-static` methods receive `jobject thiz` 
`static` methods receive `jclass clazz`.

### Common use cases

#### Access Java strings

`jstring` cannot be directly used where `char *` or `std::string` are being used, otherwise it will result in a VM crash.

JNI native methods should use JNI functions
to convert java strings to native strings and vice-versa.

1. convert `jstring` to `const char *`:  `GetStringUTFChars` converts the built-in Unicode representation of a Java string into a UTF-8 string.
```cpp
    const char *str = (*env)->GetStringUTFChars(env, prompt, 0);
    printf("%s", str);
    (*env)->ReleaseStringUTFChars(env, prompt, str);
```
When your native code is finished using the UTF-8 string, it must call `ReleaseStringUTFChars`. Failing to call this results in a memory leak.

2. Converting C style string `const char *` to `jstring` - Use `NewStringUTF`
```cpp
    ...
    char buf[128];
    scanf("%s", buf);
    return (*env)->NewStringUTF(env, buf);
```

#### working with java arrays in native methods

continue from here:
https://www.iitk.ac.in/esc101/05Aug/tutorial/native1.1/implementing/array.html